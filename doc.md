# P6_Verilog流水线(二)实验文档

## 一、CPU设计方案综述

### （一）总体设计概述

​	本CPU为Verilog实现的流水线MIPS - CPU，支持的指令集为

- MIPS-C3={LB、LBU、LH、LHU、LW、SB、SH、SW、ADD、ADDU、
  SUB、 SUBU、 MULT、 MULTU、 DIV、 DIVU、 SLL、 SRL、 SRA、 SLLV、
  SRLV、SRAV、AND、OR、XOR、NOR、ADDI、ADDIU、ANDI、ORI、
  XORI、LUI、SLT、SLTI、SLTIU、SLTU、BEQ、BNE、BLEZ、BGTZ、
  BLTZ、BGEZ、J、JAL、JALR、JR、MFHI、MFLO、MTHI、MTLO}

### （二）关键模块定义

#### 1. IFU

+ 包含功能：
  + PC(REG)
  + IM(ROM)

| 序号 | 功能名称       |
| ---- | -------------- |
| 1    | 异步复位       |
| 2    | 输出下一条指令 |
| 3    | 跳转到指定指令 |

+ 信号定义：


| 信号名     | 方向 | 位宽   | 描述         |
| ---------- | ---- | ------ | ------------ |
| clk        | in   |        | 时钟信号     |
| rst        | in   |        | 异步复位信号 |
| branchAddr | in   | [31:0] | 跳转地址     |
| branch     | in   |        | 是否跳转     |
| opCode     | out  | [31:0] | 下一条指令   |

#### 2.GRF

+ 功能：

| 序号 | 功能名称           |
| ---- | ------------------ |
| 1    | 异步复位           |
| 2    | 读指定寄存器数据x2 |
| 3    | 给指定寄存器写数据 |

+ 信号定义：

| 信号名 | 方向 | 位宽   | 描述               |
| ------ | ---- | ------ | ------------------ |
| clk    | in   |        | 时钟信号           |
| reset  | in   |        | 异步复位信号       |
| WE     | in   |        | 写使能信号         |
| A1     | in   | [4:0]  | RD1地址输入        |
| A2     | in   | [4:0]  | RD2地址输入        |
| A3     | in   | [4:0]  | WD写入地址输入     |
| WD     | in   | [31:0] | A3寄存器写入的数据 |
| RD1    | out  | [31:0] | A1寄存器读出的数据 |
| RD2    | out  | [31:0] | A2寄存器读出的数据 |

#### 3. ALU

+ 信号定义：

| 信号名    | 方向 | 位宽   | 描述         |
| --------- | ---- | ------ | ------------ |
| srcA      | in   | [31:0] | 操作数A      |
| srcB      | in   | [31:0] | 操作数B      |
| s         | in   | [4:0]  | 左移数       |
| ALUOp     | in   | [2:0]  | 操作码       |
| Zero      | out  |        | 结果是否为零 |
| ALUResult | out  | [31:0] | 运算结果     |

+ ALUOp功能表：

| ALUOp[2:0] | 定义            |
| ---------- | --------------- |
| 000        | A and B         |
| 001        | A or B          |
| 010        | A + B           |
| 011        | B << s          |
| 100        | A and $\bar{B}$ |
| 101        | A or$\bar{B}$   |
| 110        | A-  B           |
| 111        | B << 16         |

#### 4. DM

- 使用 RAM 实现，容量为 32bit * 32，应具有**异步复位**功能，复位值为0x00000000。

- **起始地址：0x00000000**。

- RAM 应使用双端口模式，即设置 RAM 的 **Data Interface** 属性为 **Separate load and store ports**。

- 功能：

  | 序号 | 功能名称             |
  | ---- | -------------------- |
  | 1    | 异步复位             |
  | 2    | 读指定地址内存数据   |
  | 3    | 给指定地址内存写数据 |

- 信号定义：

| 信号名   | 方向 | 位宽   | 描述         |
| -------- | ---- | ------ | ------------ |
| clk      | in   |        | 时钟信号     |
| reset    | in   |        | 异步复位信号 |
| MemWrite | in   |        | 写使能信号   |
| A        | in   | [31:0] | 地址输入     |
| WD       | in   | [31:0] | 写入的数据   |
| RD1      | out  | [31:0] | 读出的数据   |

#### 5. EXT

  + 使用 Logisim 内置的 Bit Extender。

  + 功能：

    | 序号 | 功能名称           |
    | ---- | ------------------ |
    | 1    | 零扩展(16 -> 32)   |
    | 2    | 符号扩展(16 -> 32) |

+ 信号定义：

| 信号名 | 方向 | 位宽   | 描述                   |
| ------ | ---- | ------ | ---------------------- |
| In     | in   | [15:0] | 输入16位数据           |
| ExtOp  | in   |        | 0为符号扩展，1为零扩展 |
| Out    | out  | [31:0] | 输出32位数据           |

#### 6. Splitter

+ 功能：

  | 序号 | 功能名称           |
  | ---- | ------------------ |
  | 1    | 输入的32位指令分解 |

+ 信号定义：

| 信号名      | 方向 | 位宽   | 描述               |
| ----------- | ---- | ------ | ------------------ |
| instructure | in   | [32:0] | 输入32位指令       |
| Op          | out  | [5:0]  | instructure[31:26] |
| Funct       | out  | [5:0]  | instructure[5:0]   |
| rs          | out  | [4:0]  | instructure[25:21] |
| rt          | out  | [4:0]  | instructure[20:16] |
| rd          | out  | [4:0]  | instructure[15:11] |
| s           | out  | [4:0]  | instructure[10:6]  |
| imme        | out  | [15:0] | instructure[15:0]  |

  #### 7. Controller

+ (下文详述)

#### 8. datapath

+ 数据通路采用黑书连接，在数据通路里把各个模块实例化。

#### 9.Mux

+ 构造了5位和32位的Mux，方便连线

#### 10.杂项

​	封装了各个级的流水线模块以及流水线寄存器。

### （三）重要机制实现方法

+ 重要机制主要是Controller的设计，便于后续加指令，采用了教程网上的先与门后或门的设计

  对于每条指令，采用如下图的处理方式：
  
  |      | opcode | Funct  | Regwrite | RegDst | W$31 | ALUSrc | Branch | MemWrite | MemtoReg | Jump | JumpToReg | ALUop    |
  | ---- | ------ | ------ | -------- | ------ | ---- | ------ | ------ | -------- | -------- | ---- | --------- | -------- |
  | addu | 000000 | 100001 | 1        | 1      | 0    | 0      | 0      | 0        | 0        | 0    | 0         | ADD 010  |
  | subu | 000000 | 100011 | 1        | 1      | 0    | 0      | 0      | 0        | 0        | 0    | 0         | SUB 110  |
  | ori  | 001101 | x      | 1        | 0      | 0    | 1      | 0      | 0        | 0        | 0    | 0         | OR 001   |
  | lw   | 100011 | x      | 1        | 0      | 0    | 1      | 0      | 0        | 1        | 0    | 0         | ADD 010  |
  | sw   | 101011 | x      | 0        | x      | 0    | 1      | 0      | 1        | x        | 0    | 0         | ADD 010  |
  | beq  | 000100 | x      | 0        | x      | 0    | 0      | 1      | 0        | x        | 0    | 0         | SUB 110  |
  | lui  | 001111 | x      | 1        | 0      | 0    | 1      | 0      | 0        | 0        | 0    | 0         | <<16 111 |
  | jal  | 000011 | x      | 1        | x      | 1    | x      | 0      | 0        | x        | 1    | 0         | x        |
  | jr   | 000000 | 001000 | 0        | x      | 0    | x      | 0      | 0        | x        | 0    | 1         | x        |
  | sll  | 000000 | 000000 | 1        | 1      | 0    | 0      | 0      | 0        | 0        | 0    | 0         | << 011   |

+ 本次采用译码——编码——译码模式，首先在头文件中定义各条指令的编码

+ 其次在指令译码器中对指令进行译码，判断指令种类，并把指令编码传给控制器

+ 最后在控制器中对新编码进行判断，传出控制信号。

+ 对于CPU的数据通路，基本采用大黑书的方案。

+ 冲突控制单元：

+ 冲突控制器

  |      | r_new | r_use1 | r_use2 | t_new | t_use1 | t_use2 |
  | ---- | ----- | ------ | ------ | ----- | ------ | ------ |
  | addu | rd    | rs     | rt     | 2     | 1      | 1      |
  | subu | rd    | rs     | rt     | 2     | 1      | 1      |
  | ori  | rt    | rs     | x      | 2     | 1      | x      |
  | lw   | rt    | rs     | x      | 3     | 1      | x      |
  | sw   | x     | rs     | rt     | x     | 1      | 2      |
  | beq  | x     | rs     | rt     | x     | 0      | 0      |
  | lui  | rt    | x      | x      | 2     | x      | x      |
  | j    | x     | x      | x      | x     | x      | x      |
  | jal  | 31    | x      | x      | 2     | x      | x      |
  | jr   | x     | rs     | x      | x     | 0      | x      |
  | sll  | rd    | x      | rt     | 2     | 1      | 1      |
  |      |       |        |        |       |        |        |

## 二、测试方案

本次测试未使用自动化测试方案

### （一）典型测试样例

#### 1. 测试ori指令

```assembly
ori $1,$1,127
```

测试ori指令时发现，ori指令需要零扩展，于是修改了EXT组件。

#### 2. 测试sll指令

```assembly
ori $1,$1,127
sll $1,$1,2
```

测试sll指令时发现，sll指令执行后寄存器为0，发现ALU操作码异常，是控制单元出现问题，修改后正常。

#### 3. 问题

使用iverilog发现：如果不开启-W all 对于端口则不会检查，之前连线出现了端口悬空的现象，结果发现是连线大小写字母问题，值得反思。

## 三、思考题

#### 1.在采用本节所述的控制冒险处理方式下，PC的值应当如何被更新？请从数据通路和控制信号两方面进行说明。

+ 本人数据通路采用的是在IF处理
+ 在ID级输出三种控制信号及其跳转地址
+ 如果三种都不是则PC+4
+ 如果暂停则pc不动

#### 2.对于jal等需要将指令地址写入寄存器的指令，为什么需要回写PC+8？

+ 因为PC+4是延迟槽

#### 3.为什么所有的供给者都是存储了上一级传来的各种数据的**流水级寄存器**，而不是由ALU或者DM等部件来提供数据？

+ 因为有可能转发多次（转发的转发）

#### 4.Thinking

+ ***\*Thinking 1\****：如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。
  + 连续转发转发不到
+ ***\*Thinking 2\****：我们为什么要对GPR采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？
  + 从WB到ID级的转发
+ ***\*Thinking 3\****：为什么0号寄存器需要特殊处理？
  + 因为\$0没法写入
+ ***\*Thinking 4\****：什么是“最新产生的数据”？
  + 最近那一级产生的数据

#### 5.在AT方法讨论转发条件的时候，只提到了“供给者需求者的A相同，且不为0”，但在CPU写入GRF的时候，是有一个we信号来控制是否要写入的。为何在AT方法中不需要特判we呢？为了**用且仅用**A和T完成转发，在翻译出A的时候，要结合we做什么操作呢？

+ 如果WE==0，A=0？

#### 6. 

+ 手动构造，分析可能出现的冲突情况进行处理。