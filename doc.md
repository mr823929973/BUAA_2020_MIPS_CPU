# P6_Verilog流水线(二)实验文档

## 一、CPU设计方案综述

### （一）总体设计概述

​	本CPU为Verilog实现的流水线MIPS - CPU，支持的指令集为

- MIPS-C3={LB、LBU、LH、LHU、LW、SB、SH、SW、ADD、ADDU、
  SUB、 SUBU、 MULT、 MULTU、 DIV、 DIVU、 SLL、 SRL、 SRA、 SLLV、
  SRLV、SRAV、AND、OR、XOR、NOR、ADDI、ADDIU、ANDI、ORI、
  XORI、LUI、SLT、SLTI、SLTIU、SLTU、BEQ、BNE、BLEZ、BGTZ、
  BLTZ、BGEZ、J、JAL、JALR、JR、MFHI、MFLO、MTHI、MTLO}

### （二）关键模块定义

#### 1. IFU

+ 包含功能：
  + PC(REG)
  + IM(ROM)

| 序号 | 功能名称       |
| ---- | -------------- |
| 1    | 异步复位       |
| 2    | 输出下一条指令 |
| 3    | 跳转到指定指令 |

+ 信号定义：


| 信号名     | 方向 | 位宽   | 描述         |
| ---------- | ---- | ------ | ------------ |
| clk        | in   |        | 时钟信号     |
| rst        | in   |        | 异步复位信号 |
| branchAddr | in   | [31:0] | 跳转地址     |
| branch     | in   |        | 是否跳转     |
| opCode     | out  | [31:0] | 下一条指令   |

#### 2.GRF

+ 功能：

| 序号 | 功能名称           |
| ---- | ------------------ |
| 1    | 异步复位           |
| 2    | 读指定寄存器数据x2 |
| 3    | 给指定寄存器写数据 |

+ 信号定义：

| 信号名 | 方向 | 位宽   | 描述               |
| ------ | ---- | ------ | ------------------ |
| clk    | in   |        | 时钟信号           |
| reset  | in   |        | 异步复位信号       |
| WE     | in   |        | 写使能信号         |
| A1     | in   | [4:0]  | RD1地址输入        |
| A2     | in   | [4:0]  | RD2地址输入        |
| A3     | in   | [4:0]  | WD写入地址输入     |
| WD     | in   | [31:0] | A3寄存器写入的数据 |
| RD1    | out  | [31:0] | A1寄存器读出的数据 |
| RD2    | out  | [31:0] | A2寄存器读出的数据 |

#### 3. ALU

+ 信号定义：

| 信号名    | 方向 | 位宽   | 描述         |
| --------- | ---- | ------ | ------------ |
| srcA      | in   | [31:0] | 操作数A      |
| srcB      | in   | [31:0] | 操作数B      |
| s         | in   | [4:0]  | 左移数       |
| ALUOp     | in   | [2:0]  | 操作码       |
| Zero      | out  |        | 结果是否为零 |
| ALUResult | out  | [31:0] | 运算结果     |

+ ALUOp功能表：

| ALUOp[2:0] | 定义            |
| ---------- | --------------- |
| 000        | A and B         |
| 001        | A or B          |
| 010        | A + B           |
| 011        | B << s          |
| 100        | A and $\bar{B}$ |
| 101        | A or$\bar{B}$   |
| 110        | A-  B           |
| 111        | B << 16         |

#### 4. DM

- 使用 RAM 实现，容量为 32bit * 32，应具有**异步复位**功能，复位值为0x00000000。

- **起始地址：0x00000000**。

- RAM 应使用双端口模式，即设置 RAM 的 **Data Interface** 属性为 **Separate load and store ports**。

- 功能：

  | 序号 | 功能名称             |
  | ---- | -------------------- |
  | 1    | 异步复位             |
  | 2    | 读指定地址内存数据   |
  | 3    | 给指定地址内存写数据 |

- 信号定义：

| 信号名   | 方向 | 位宽   | 描述         |
| -------- | ---- | ------ | ------------ |
| clk      | in   |        | 时钟信号     |
| reset    | in   |        | 异步复位信号 |
| MemWrite | in   |        | 写使能信号   |
| A        | in   | [31:0] | 地址输入     |
| WD       | in   | [31:0] | 写入的数据   |
| RD1      | out  | [31:0] | 读出的数据   |

#### 5. EXT

  + 使用 Logisim 内置的 Bit Extender。

  + 功能：

    | 序号 | 功能名称           |
    | ---- | ------------------ |
    | 1    | 零扩展(16 -> 32)   |
    | 2    | 符号扩展(16 -> 32) |

+ 信号定义：

| 信号名 | 方向 | 位宽   | 描述                   |
| ------ | ---- | ------ | ---------------------- |
| In     | in   | [15:0] | 输入16位数据           |
| ExtOp  | in   |        | 0为符号扩展，1为零扩展 |
| Out    | out  | [31:0] | 输出32位数据           |

#### 6. Splitter

+ 功能：

  | 序号 | 功能名称           |
  | ---- | ------------------ |
  | 1    | 输入的32位指令分解 |

+ 信号定义：

| 信号名      | 方向 | 位宽   | 描述               |
| ----------- | ---- | ------ | ------------------ |
| instructure | in   | [32:0] | 输入32位指令       |
| Op          | out  | [5:0]  | instructure[31:26] |
| Funct       | out  | [5:0]  | instructure[5:0]   |
| rs          | out  | [4:0]  | instructure[25:21] |
| rt          | out  | [4:0]  | instructure[20:16] |
| rd          | out  | [4:0]  | instructure[15:11] |
| s           | out  | [4:0]  | instructure[10:6]  |
| imme        | out  | [15:0] | instructure[15:0]  |

  #### 7. Controller

+ (下文详述)

#### 8. datapath

+ 数据通路采用黑书连接，在数据通路里把各个模块实例化。

#### 9.Mux

+ 构造了5位和32位的Mux，方便连线

#### 10.杂项

​	封装了各个级的流水线模块以及流水线寄存器。

### （三）重要机制实现方法

+ 重要机制主要是Controller的设计，便于后续加指令，采用了教程网上的先与门后或门的设计

  对于每条指令，采用如下图的处理方式：
  
  |      | opcode | Funct  | Regwrite | RegDst | W$31 | ALUSrc | Branch | MemWrite | MemtoReg | Jump | JumpToReg | ALUop    |
  | ---- | ------ | ------ | -------- | ------ | ---- | ------ | ------ | -------- | -------- | ---- | --------- | -------- |
  | addu | 000000 | 100001 | 1        | 1      | 0    | 0      | 0      | 0        | 0        | 0    | 0         | ADD 010  |
  | subu | 000000 | 100011 | 1        | 1      | 0    | 0      | 0      | 0        | 0        | 0    | 0         | SUB 110  |
  | ori  | 001101 | x      | 1        | 0      | 0    | 1      | 0      | 0        | 0        | 0    | 0         | OR 001   |
  | lw   | 100011 | x      | 1        | 0      | 0    | 1      | 0      | 0        | 1        | 0    | 0         | ADD 010  |
  | sw   | 101011 | x      | 0        | x      | 0    | 1      | 0      | 1        | x        | 0    | 0         | ADD 010  |
  | beq  | 000100 | x      | 0        | x      | 0    | 0      | 1      | 0        | x        | 0    | 0         | SUB 110  |
  | lui  | 001111 | x      | 1        | 0      | 0    | 1      | 0      | 0        | 0        | 0    | 0         | <<16 111 |
  | jal  | 000011 | x      | 1        | x      | 1    | x      | 0      | 0        | x        | 1    | 0         | x        |
  | jr   | 000000 | 001000 | 0        | x      | 0    | x      | 0      | 0        | x        | 0    | 1         | x        |
  | sll  | 000000 | 000000 | 1        | 1      | 0    | 0      | 0      | 0        | 0        | 0    | 0         | << 011   |

+ 本次采用译码——编码——译码模式，首先在头文件中定义各条指令的编码

+ 其次在指令译码器中对指令进行译码，判断指令种类，并把指令编码传给控制器

+ 最后在控制器中对新编码进行判断，传出控制信号。

+ 对于CPU的数据通路，基本采用大黑书的方案。

+ 冲突控制单元：

+ 冲突控制器

  |      | r_new | r_use1 | r_use2 | t_new | t_use1 | t_use2 |
  | ---- | ----- | ------ | ------ | ----- | ------ | ------ |
  | addu | rd    | rs     | rt     | 2     | 1      | 1      |
  | subu | rd    | rs     | rt     | 2     | 1      | 1      |
  | ori  | rt    | rs     | x      | 2     | 1      | x      |
  | lw   | rt    | rs     | x      | 3     | 1      | x      |
  | sw   | x     | rs     | rt     | x     | 1      | 2      |
  | beq  | x     | rs     | rt     | x     | 0      | 0      |
  | lui  | rt    | x      | x      | 2     | x      | x      |
  | j    | x     | x      | x      | x     | x      | x      |
  | jal  | 31    | x      | x      | 2     | x      | x      |
  | jr   | x     | rs     | x      | x     | 0      | x      |
  | sll  | rd    | x      | rt     | 2     | 1      | 1      |
  |      |       |        |        |       |        |        |

## 二、测试方案

本次测试未使用自动化测试方案

### （一）典型测试样例

#### 1. 测试ori指令

```assembly
ori $1,$1,127
```

测试ori指令时发现，ori指令需要零扩展，于是修改了EXT组件。

#### 2. 测试sll指令

```assembly
ori $1,$1,127
sll $1,$1,2
```

测试sll指令时发现，sll指令执行后寄存器为0，发现ALU操作码异常，是控制单元出现问题，修改后正常。

#### 3. 问题

使用iverilog发现：如果不开启-W all 对于端口则不会检查，之前连线出现了端口悬空的现象，结果发现是连线大小写字母问题，值得反思。

指令较多，一定要反复检查

## 三、思考题

+ 为什么需要有单独的乘除法部件而不是整合进ALU？为何需要有独立的HI、LO寄存器？

  因为乘除慢，减短关键路径，不影响别的指令

+ 参照你对延迟槽的理解，试解释“乘除槽”。

  五周期nop

+ 举例说明并分析何时按字节访问内存相对于按字访问内存性能上更有优势。（Hint： 考虑C语言中字符串的情况）

  遍历字符串

+ 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？

  tnew/tuse填表解决

如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证**覆盖**了所有需要测试的情况；如果你是**完全随机**生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了**特殊的策略**，比如构造连续数据冒险序列，请你描述一下你使用的策略如何**结合了随机性**达到强测的效果。

此思考题请同学们结合自己测试CPU使用的具体手段，按照自己的实际情况进行回答

- 为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？

手工测试