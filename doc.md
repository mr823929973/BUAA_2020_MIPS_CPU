# P3_Verilog单周期实验文档

## 一、CPU设计方案综述

### （一）总体设计概述

​	本CPU为Logisim实现的单周期MIPS - CPU，支持的指令集包含**{addu, subu, ori, lw, sw, beq, lui, jal, jr,nop,sll}**。为了实现这些功能，CPU主要包含了IFU、GRF、ALU、DM、EXT、Controller、Splitter等模块。

### （二）关键模块定义

#### 1. IFU

+ 包含功能：
  + PC(REG)
  + IM(ROM)

| 序号 | 功能名称       |
| ---- | -------------- |
| 1    | 异步复位       |
| 2    | 输出下一条指令 |
| 3    | 跳转到指定指令 |

+ 信号定义：


| 信号名     | 方向 | 位宽   | 描述         |
| ---------- | ---- | ------ | ------------ |
| clk        | in   |        | 时钟信号     |
| rst        | in   |        | 异步复位信号 |
| branchAddr | in   | [31:0] | 跳转地址     |
| branch     | in   |        | 是否跳转     |
| opCode     | out  | [31:0] | 下一条指令   |

#### 2.GRF

+ 功能：

| 序号 | 功能名称           |
| ---- | ------------------ |
| 1    | 异步复位           |
| 2    | 读指定寄存器数据x2 |
| 3    | 给指定寄存器写数据 |

+ 信号定义：

| 信号名 | 方向 | 位宽   | 描述               |
| ------ | ---- | ------ | ------------------ |
| clk    | in   |        | 时钟信号           |
| reset  | in   |        | 异步复位信号       |
| WE     | in   |        | 写使能信号         |
| A1     | in   | [4:0]  | RD1地址输入        |
| A2     | in   | [4:0]  | RD2地址输入        |
| A3     | in   | [4:0]  | WD写入地址输入     |
| WD     | in   | [31:0] | A3寄存器写入的数据 |
| RD1    | out  | [31:0] | A1寄存器读出的数据 |
| RD2    | out  | [31:0] | A2寄存器读出的数据 |

#### 3. ALU

+ 信号定义：

| 信号名    | 方向 | 位宽   | 描述         |
| --------- | ---- | ------ | ------------ |
| srcA      | in   | [31:0] | 操作数A      |
| srcB      | in   | [31:0] | 操作数B      |
| s         | in   | [4:0]  | 左移数       |
| ALUOp     | in   | [2:0]  | 操作码       |
| Zero      | out  |        | 结果是否为零 |
| ALUResult | out  | [31:0] | 运算结果     |

+ ALUOp功能表：

| ALUOp[2:0] | 定义            |
| ---------- | --------------- |
| 000        | A and B         |
| 001        | A or B          |
| 010        | A + B           |
| 011        | B << s          |
| 100        | A and $\bar{B}$ |
| 101        | A or$\bar{B}$   |
| 110        | A-  B           |
| 111        | B << 16         |

#### 4. DM

- 使用 RAM 实现，容量为 32bit * 32，应具有**异步复位**功能，复位值为0x00000000。

- **起始地址：0x00000000**。

- RAM 应使用双端口模式，即设置 RAM 的 **Data Interface** 属性为 **Separate load and store ports**。

- 功能：

  | 序号 | 功能名称             |
  | ---- | -------------------- |
  | 1    | 异步复位             |
  | 2    | 读指定地址内存数据   |
  | 3    | 给指定地址内存写数据 |

- 信号定义：

| 信号名   | 方向 | 位宽   | 描述         |
| -------- | ---- | ------ | ------------ |
| clk      | in   |        | 时钟信号     |
| reset    | in   |        | 异步复位信号 |
| MemWrite | in   |        | 写使能信号   |
| A        | in   | [31:0] | 地址输入     |
| WD       | in   | [31:0] | 写入的数据   |
| RD1      | out  | [31:0] | 读出的数据   |

#### 5. EXT

  + 使用 Logisim 内置的 Bit Extender。

  + 功能：

    | 序号 | 功能名称           |
    | ---- | ------------------ |
    | 1    | 零扩展(16 -> 32)   |
    | 2    | 符号扩展(16 -> 32) |

+ 信号定义：

| 信号名 | 方向 | 位宽   | 描述                   |
| ------ | ---- | ------ | ---------------------- |
| In     | in   | [15:0] | 输入16位数据           |
| ExtOp  | in   |        | 0为符号扩展，1为零扩展 |
| Out    | out  | [31:0] | 输出32位数据           |

#### 6. Splitter

+ 功能：

  | 序号 | 功能名称           |
  | ---- | ------------------ |
  | 1    | 输入的32位指令分解 |

+ 信号定义：

| 信号名      | 方向 | 位宽   | 描述               |
| ----------- | ---- | ------ | ------------------ |
| instructure | in   | [32:0] | 输入32位指令       |
| Op          | out  | [5:0]  | instructure[31:26] |
| Funct       | out  | [5:0]  | instructure[5:0]   |
| rs          | out  | [4:0]  | instructure[25:21] |
| rt          | out  | [4:0]  | instructure[20:16] |
| rd          | out  | [4:0]  | instructure[15:11] |
| s           | out  | [4:0]  | instructure[10:6]  |
| imme        | out  | [15:0] | instructure[15:0]  |

  #### 7. Controller

+ (下文详述)

#### 8. datapath

+ 数据通路采用黑书连接，在数据通路里把各个模块实例化。

#### 9.Mux

+ 构造了5位和32位的Mux，方便连线

### （三）重要机制实现方法

+ 重要机制主要是Controller的设计，便于后续加指令，采用了教程网上的先与门后或门的设计

  对于每条指令，采用如下图的处理方式：
  
  |      | opcode | Funct  | Regwrite | RegDst | W$31 | ALUSrc | Branch | MemWrite | MemtoReg | Jump | JumpToReg | ALUop    |
  | ---- | ------ | ------ | -------- | ------ | ---- | ------ | ------ | -------- | -------- | ---- | --------- | -------- |
  | addu | 000000 | 100001 | 1        | 1      | 0    | 0      | 0      | 0        | 0        | 0    | 0         | ADD 010  |
  | subu | 000000 | 100011 | 1        | 1      | 0    | 0      | 0      | 0        | 0        | 0    | 0         | SUB 110  |
  | ori  | 001101 | x      | 1        | 0      | 0    | 1      | 0      | 0        | 0        | 0    | 0         | OR 001   |
  | lw   | 100011 | x      | 1        | 0      | 0    | 1      | 0      | 0        | 1        | 0    | 0         | ADD 010  |
  | sw   | 101011 | x      | 0        | x      | 0    | 1      | 0      | 1        | x        | 0    | 0         | ADD 010  |
  | beq  | 000100 | x      | 0        | x      | 0    | 0      | 1      | 0        | x        | 0    | 0         | SUB 110  |
| lui  | 001111 | x      | 1        | 0      | 0    | 1      | 0      | 0        | 0        | 0    | 0         | <<16 111 |
  | jal  | 000011 | x      | 1        | x      | 1    | x      | 0      | 0        | x        | 1    | 0         | x        |
| jr   | 000000 | 001000 | 0        | x      | 0    | x      | 0      | 0        | x        | 0    | 1         | x        |
  | sll  | 000000 | 000000 | 1        | 1      | 0    | 0      | 0      | 0        | 0        | 0    | 0         | << 011   |

+ 本次采用译码——编码——译码模式，首先在头文件中定义各条指令的编码

+ 其次在指令译码器中对指令进行译码，判断指令种类，并把指令编码传给控制器

+ 最后在控制器中对新编码进行判断，传出控制信号。

+ 对于CPU的数据通路，基本采用大黑书的方案。

  

## 二、测试方案

本次测试未使用自动化测试方案

### （一）典型测试样例

#### 1. 测试ori指令

```assembly
ori $1,$1,127
```

测试ori指令时发现，ori指令需要零扩展，于是修改了EXT组件。

#### 2. 测试sll指令

```assembly
ori $1,$1,127
sll $1,$1,2
```

测试sll指令时发现，sll指令执行后寄存器为0，发现ALU操作码异常，是控制单元出现问题，修改后正常。

#### 3. 问题

使用iverilog发现：如果不开启-W all 对于端口则不会检查，之前连线出现了端口悬空的现象，结果发现是连线大小写字母问题，值得反思。

## 三、思考题

#### 1. 根据你的理解，在下面给出的DM的输入示例中，地址信号addr位数为什么是[11:2]而不是[9:0]？这个addr信号又是从哪里来的？

+ 因为是4B对齐
+ 从ALU来的

#### 2. 思考Verilog语言设计控制器的译码方式，给出代码示例，并尝试对比各方式的优劣。

+ 代码示例见实验代码仓库
+ 本人采用指令译码器与控制器分开的方式，先判断指令，后给出操作。（先列表，然后在代码中填表）文档就显得尤为重要

#### 3. 在相应的部件中，**reset的优先级**比其他控制信号（不包括clk信号）都要**高**，且相应的设计都是**同步复位**。清零信号reset所驱动的部件具有什么共同特点？

+ 都有时序存储器

#### 4. C语言是一种弱类型程序设计语言。C语言中不对计算结果溢出进行处理，这意味着C语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持C语言，MIPS指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi与addiu是等价的，add与addu是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的Operation部分 。

+ add,addi 如果考虑溢出,则在溢出时抛出错误信息,不溢出时进行加法运算。如果忽略溢出,则不存在抛出错误情况,直接进行加法运算,则与 addu,addiu 操作相同

#### 5.根据自己的设计说明单周期处理器的优缺点。

+ 优点：设计简单，数据通路简单
+ 缺点：效率低