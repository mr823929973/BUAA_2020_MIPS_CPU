# P3_Logisim单周期实验文档

## 一、CPU设计方案综述

### （一）总体设计概述

​	本CPU为Logisim实现的单周期MIPS - CPU，支持的指令集包含{addu、subu、ori、lw、sw、beq、lui、sll、nop}。为了实现这些功能，CPU主要包含了IFU、GRF、ALU、DM、EXT、Controller、Splitter等模块。

### （二）关键模块定义

#### 1. IFU

+ 包含功能：
  + PC(REG)
  + IM(ROM)

| 序号 | 功能名称       |
| ---- | -------------- |
| 1    | 异步复位       |
| 2    | 输出下一条指令 |
| 3    | 跳转到指定指令 |

+ 信号定义：


| 信号名     | 方向 | 位宽   | 描述         |
| ---------- | ---- | ------ | ------------ |
| clk        | in   |        | 时钟信号     |
| rst        | in   |        | 异步复位信号 |
| branchAddr | in   | [31:0] | 跳转地址     |
| branch     | in   |        | 是否跳转     |
| opCode     | out  | [31:0] | 下一条指令   |

#### 2.GRF

+ 功能：

| 序号 | 功能名称           |
| ---- | ------------------ |
| 1    | 异步复位           |
| 2    | 读指定寄存器数据x2 |
| 3    | 给指定寄存器写数据 |

+ 信号定义：

| 信号名 | 方向 | 位宽   | 描述               |
| ------ | ---- | ------ | ------------------ |
| clk    | in   |        | 时钟信号           |
| reset  | in   |        | 异步复位信号       |
| WE     | in   |        | 写使能信号         |
| A1     | in   | [4:0]  | RD1地址输入        |
| A2     | in   | [4:0]  | RD2地址输入        |
| A3     | in   | [4:0]  | WD写入地址输入     |
| WD     | in   | [31:0] | A3寄存器写入的数据 |
| RD1    | out  | [31:0] | A1寄存器读出的数据 |
| RD2    | out  | [31:0] | A2寄存器读出的数据 |

#### 3. ALU

+ 信号定义：

| 信号名    | 方向 | 位宽   | 描述         |
| --------- | ---- | ------ | ------------ |
| srcA      | in   | [31:0] | 操作数A      |
| srcB      | in   | [31:0] | 操作数B      |
| s         | in   | [4:0]  | 左移数       |
| ALUOp     | in   | [2:0]  | 操作码       |
| Zero      | out  |        | 结果是否为零 |
| ALUResult | out  | [31:0] | 运算结果     |

+ ALUOp功能表：

| ALUOp[2:0] | 定义            |
| ---------- | --------------- |
| 000        | A and B         |
| 001        | A or B          |
| 010        | A + B           |
| 011        | B << s          |
| 100        | A and $\bar{B}$ |
| 101        | A or$\bar{B}$   |
| 110        | A-  B           |
| 111        | B << 16         |

#### 4. DM

- 使用 RAM 实现，容量为 32bit * 32，应具有**异步复位**功能，复位值为0x00000000。

- **起始地址：0x00000000**。

- RAM 应使用双端口模式，即设置 RAM 的 **Data Interface** 属性为 **Separate load and store ports**。

- 功能：

  | 序号 | 功能名称             |
  | ---- | -------------------- |
  | 1    | 异步复位             |
  | 2    | 读指定地址内存数据   |
  | 3    | 给指定地址内存写数据 |

- 信号定义：

| 信号名   | 方向 | 位宽   | 描述         |
| -------- | ---- | ------ | ------------ |
| clk      | in   |        | 时钟信号     |
| reset    | in   |        | 异步复位信号 |
| MemWrite | in   |        | 写使能信号   |
| A        | in   | [4:0]  | 地址输入     |
| WD       | in   | [31:0] | 写入的数据   |
| RD1      | out  | [31:0] | 读出的数据   |

#### 5. EXT

  + 使用 Logisim 内置的 Bit Extender。

  + 功能：

    | 序号 | 功能名称           |
    | ---- | ------------------ |
    | 1    | 零扩展(16 -> 32)   |
    | 2    | 符号扩展(16 -> 32) |

+ 信号定义：

| 信号名 | 方向 | 位宽   | 描述                   |
| ------ | ---- | ------ | ---------------------- |
| In     | in   | [15:0] | 输入16位数据           |
| ExtOp  | in   |        | 0为符号扩展，1为零扩展 |
| Out    | out  | [31:0] | 输出32位数据           |

#### 6. Splitter

+ logisim自带的splitter太难用了

  + 功能：

    | 序号 | 功能名称           |
    | ---- | ------------------ |
    | 1    | 输入的32位指令分解 |

+ 信号定义：

| 信号名      | 方向 | 位宽   | 描述               |
| ----------- | ---- | ------ | ------------------ |
| instructure | in   | [32:0] | 输入32位指令       |
| Op          | out  | [5:0]  | instructure[31:26] |
| Funct       | out  | [5:0]  | instructure[5:0]   |
| rs          | out  | [4:0]  | instructure[25:21] |
| rt          | out  | [4:0]  | instructure[20:16] |
| rd          | out  | [4:0]  | instructure[15:11] |
| s           | out  | [4:0]  | instructure[10:6]  |
| imme        | out  | [15:0] | instructure[15:0]  |

  #### 7. Controller

+ (下文详述)

  先放一张网上的图（![img](/home/buaa-city/co/P3_L0_T3_0.png)

### （三）重要机制实现方法

+ 重要机制主要是Controller的设计，便于后续加指令，采用了教程网上的先与门后或门的设计

  |      | opcode | Funct  | Regwrite | RegDst | ALUSrc | Branch | MenWrite | MemtoReg | AluOp    |
  | ---- | ------ | ------ | -------- | ------ | ------ | ------ | -------- | -------- | -------- |
  | addu | 000000 | 100001 | 1        | 1      | 0      | 0      | 0        | 0        | ADD 010  |
  | subu | 000000 | 100011 | 1        | 1      | 0      | 0      | 0        | 0        | SUB 110  |
  | ori  | 001101 | x      | 1        | 0      | 1      | 0      | 0        | 0        | OR 001   |
  | lw   | 100011 | x      | 1        | 0      | 1      | 0      | 0        | 1        | ADD 010  |
  | sw   | 101011 | x      | 0        | x      | 1      | 0      | 1        | x        | ADD 010  |
  | beq  | 000100 | x      | 0        | x      | 0      | 1      | 0        | x        | SUB 110  |
  | lui  | 001111 | x      | 1        | 0      | 1      | 0      | 0        | 0        | <<16 111 |
  | sll  | 000000 | 000000 | 1        | 1      | 0      | 0      | 0        | 0        | <<  011  |

  对于每条指令，采用如下图的处理方式：

  

  ![image-20201112205538191](/home/buaa-city/co/image-20201112205538191.png)

对于每个控制信号，采用如下图的处理方式

![image-20201112205637661](/home/buaa-city/co/image-20201112205637661.png)

后续如需增加指令，则只需增加一个与门，在相应控制信号或门增加标签，或增加新的控制信号（或门）即可。

+ 对于CPU的数据通路，基本采用大黑书的方案。

  

## 二、测试方案

本次测试未使用自动化测试方案

### （一）典型测试样例

#### 1. 测试ori指令

```assembly
ori $1,$1,127
```

测试ori指令时发现，ori指令需要零扩展，于是修改了EXT组件。

#### 2. 测试sll指令

```assembly
ori $1,$1,127
sll $1,$1,2
```

测试sll指令时发现，sll指令执行后寄存器为0，发现ALU操作码异常，是控制单元出现问题，修改后正常。

## 三、思考题

#### 1. 现在我们的模块中IM使用ROM， DM使用RAM， GRF使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

+ 不太合理，指令和数据应在一个地址空间，而且RAM不利于实现lb，lh，sb，sh等指令，还需要额外封装DM

#### 2. 事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由。

+ 因为空指令不满足任何一个已有的指令，控制器不会发出任何控制信号，所以在这个时钟周期CPU没有任何有用的操作。

#### 3.上文提到，MARS不能导出PC与DM起始地址均为0的机器码。实际上，可以通过为DM增添片选信号，来避免手工修改的麻烦，请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法

+ 假设DM有256MB，映射在0x30000000-0x3fffffff，只需把高四位地址与0x3进行比较，比较结果就是DM的片选信号(看是否落在这个空间内)

#### 4.除了编写程序进行测试外，还有一种验证CPU设计正确性的办法——形式验证。 **形式验证**的含义是根据某个或某些形式规范或属性，使用数学的方法证明其正确性或非正确性。请搜索“形式验证（Formal Verification)”了解相关内容后，简要阐述相比于测试，形式验证的优劣之处。

+ 在集成电路设计中，形式验证是一种集成电路设计的验证方法，它的主要思想是通过使用形式证明的方式来验证一个设计的功能是否正确。形式验证可以分为三大类：抽象解释（Abstract Interpretation）、形式模型检查（Formal Model Checking，也被称作特性检查）和定理证明（Theory Prover）。
+ 软件测试无法证明系统不存在缺陷，也不能证明它符合一定的属性。只有形式化验证过程可以证明一个系统不存在某个缺陷或符合某个或某些属性。系统无法被证明或测试为无缺陷，这是因为不可能形式地规定什么是“没有缺陷”。
+ 所以形式验证能直接证明系统存不存在缺陷，经过形式验证的系统一定是符合某种属性的，但形式验证的可行性低，许多命题不能或难以证明，只有在严谨性要求非常高的领域（如：航空航天、医疗、金融等）才会使用形式验证，对于一般的软件或硬件开发，通常认为充分的测试已经能满足系统的正确性。

